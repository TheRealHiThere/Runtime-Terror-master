#![allow(non_camel_case_types)]
#![allow(unused)]

#[derive(Debug, Eq, PartialEq, Clone, Copy)]
pub enum TEXT_TOKEN {
    TEXT_FUNCTION_DECLARATION_1,
    TEXT_FUNCTION_DECLARATION_2,

    TEXT_CLASS_DECLARATION_1,
    TEXT_CLASS_DECLARATION_2,

    TEXT_ENUM_DECLARATION_1,
    TEXT_ENUM_DECLARATION_2,
    TEXT_ENUM_DECLARATION_3,
    TEXT_ENUM_DECLARATION_4,

    TEXT_VAR_DECLARATION_1,
    TEXT_VAR_DECLARATION_2,
    TEXT_VAR_DECLARATION_3,

    TEXT_MUT_DECLARATION_1,
    TEXT_MUT_DECLARATION_2,
    TEXT_MUT_DECLARATION_3,

    TEXT_PUB_DECLARATION_2,
    TEXT_PUB_DECLARATION_1,
    TEXT_PUB_DECLARATION_3,

    TEXT_NEW_DECLARATION_1,
    TEXT_NEW_DECLARATION_2,
    TEXT_NEW_DECLARATION_3,

    TEXT_CONST_DECLARATION_1,
    TEXT_CONST_DECLARATION_2,
    TEXT_CONST_DECLARATION_3,
    TEXT_CONST_DECLARATION_4,
    TEXT_CONST_DECLARATION_5,

    TEXT_TYPE_DECLARATION_1,
    TEXT_TYPE_DECLARATION_2,
    TEXT_TYPE_DECLARATION_3,
    TEXT_TYPE_DECLARATION_4,

    TEXT_SWITCH_DECLARATION_1,
    TEXT_SWITCH_DECLARATION_2,
    TEXT_SWITCH_DECLARATION_3,
    TEXT_SWITCH_DECLARATION_4,
    TEXT_SWITCH_DECLARATION_5,
    TEXT_SWITCH_DECLARATION_6,

    TEXT_RETURN_DECLARATION_1,
    TEXT_RETURN_DECLARATION_2,
    TEXT_RETURN_DECLARATION_3,
    TEXT_RETURN_DECLARATION_4,
    TEXT_RETURN_DECLARATION_5,
    TEXT_RETURN_DECLARATION_6,

    TEXT_DERIVE_DECLARATION_1,
    TEXT_DERIVE_DECLARATION_2,
    TEXT_DERIVE_DECLARATION_3,
    TEXT_DERIVE_DECLARATION_4,
    TEXT_DERIVE_DECLARATION_5,
    TEXT_DERIVE_DECLARATION_6,

    TEXT_STATIC_DECLARATION_1,
    TEXT_STATIC_DECLARATION_2,
    TEXT_STATIC_DECLARATION_3,
    TEXT_STATIC_DECLARATION_4,
    TEXT_STATIC_DECLARATION_5,
    TEXT_STATIC_DECLARATION_6,

    TEXT_UNSAFE_DECLARATION_1,
    TEXT_UNSAFE_DECLARATION_2,
    TEXT_UNSAFE_DECLARATION_3,
    TEXT_UNSAFE_DECLARATION_4,
    TEXT_UNSAFE_DECLARATION_5,
    TEXT_UNSAFE_DECLARATION_6,

    TEXT_IMPORT_DECLARATION_1,
    TEXT_IMPORT_DECLARATION_2,
    TEXT_IMPORT_DECLARATION_3,
    TEXT_IMPORT_DECLARATION_4,
    TEXT_IMPORT_DECLARATION_5,
    TEXT_IMPORT_DECLARATION_6,

    TEXT_OTHER(char),
    TEXT_DEC(char),
}
impl TEXT_TOKEN {
    pub fn tostr(&self) -> char { self.into() }
}
impl Into<char> for TEXT_TOKEN {
    fn into(self) -> char {
        match self {
            TEXT_TOKEN::TEXT_FUNCTION_DECLARATION_1 => 'f',
            TEXT_TOKEN::TEXT_FUNCTION_DECLARATION_2 => 'n',
            TEXT_TOKEN::TEXT_CLASS_DECLARATION_1 => 'c',
            TEXT_TOKEN::TEXT_CLASS_DECLARATION_2 => 'l',
            TEXT_TOKEN::TEXT_ENUM_DECLARATION_1 => 'e',
            TEXT_TOKEN::TEXT_ENUM_DECLARATION_2 => 'n',
            TEXT_TOKEN::TEXT_ENUM_DECLARATION_3 => 'u',
            TEXT_TOKEN::TEXT_ENUM_DECLARATION_4 => 'm',
            TEXT_TOKEN::TEXT_VAR_DECLARATION_1 => 'v',
            TEXT_TOKEN::TEXT_VAR_DECLARATION_2 => 'a',
            TEXT_TOKEN::TEXT_VAR_DECLARATION_3 => 'r',
            TEXT_TOKEN::TEXT_MUT_DECLARATION_1 => 'm',
            TEXT_TOKEN::TEXT_MUT_DECLARATION_2 => 'u',
            TEXT_TOKEN::TEXT_MUT_DECLARATION_3 => 't',
            TEXT_TOKEN::TEXT_PUB_DECLARATION_2 => 'p',
            TEXT_TOKEN::TEXT_PUB_DECLARATION_1 => 'u',
            TEXT_TOKEN::TEXT_PUB_DECLARATION_3 => 'b',
            TEXT_TOKEN::TEXT_CONST_DECLARATION_1 => 'c',
            TEXT_TOKEN::TEXT_CONST_DECLARATION_2 => 'o',
            TEXT_TOKEN::TEXT_CONST_DECLARATION_3 => 'n',
            TEXT_TOKEN::TEXT_CONST_DECLARATION_4 => 's',
            TEXT_TOKEN::TEXT_CONST_DECLARATION_5 => 't',
            TEXT_TOKEN::TEXT_TYPE_DECLARATION_1 => 't',
            TEXT_TOKEN::TEXT_TYPE_DECLARATION_2 => 'y',
            TEXT_TOKEN::TEXT_TYPE_DECLARATION_3 => 'p',
            TEXT_TOKEN::TEXT_TYPE_DECLARATION_4 => 'e',
            TEXT_TOKEN::TEXT_SWITCH_DECLARATION_1 => 's',
            TEXT_TOKEN::TEXT_SWITCH_DECLARATION_2 => 'w',
            TEXT_TOKEN::TEXT_SWITCH_DECLARATION_3 => 'i',
            TEXT_TOKEN::TEXT_SWITCH_DECLARATION_4 => 't',
            TEXT_TOKEN::TEXT_SWITCH_DECLARATION_5 => 'c',
            TEXT_TOKEN::TEXT_SWITCH_DECLARATION_6 => 'h',
            TEXT_TOKEN::TEXT_RETURN_DECLARATION_1 => 'r',
            TEXT_TOKEN::TEXT_RETURN_DECLARATION_2 => 'e',
            TEXT_TOKEN::TEXT_RETURN_DECLARATION_3 => 't',
            TEXT_TOKEN::TEXT_RETURN_DECLARATION_4 => 'u',
            TEXT_TOKEN::TEXT_RETURN_DECLARATION_5 => 'r',
            TEXT_TOKEN::TEXT_RETURN_DECLARATION_6 => 'n',
            TEXT_TOKEN::TEXT_DERIVE_DECLARATION_1 => 'd',
            TEXT_TOKEN::TEXT_DERIVE_DECLARATION_2 => 'e',
            TEXT_TOKEN::TEXT_DERIVE_DECLARATION_3 => 'r',
            TEXT_TOKEN::TEXT_DERIVE_DECLARATION_4 => 'i',
            TEXT_TOKEN::TEXT_DERIVE_DECLARATION_5 => 'v',
            TEXT_TOKEN::TEXT_DERIVE_DECLARATION_6 => 'e',
            TEXT_TOKEN::TEXT_STATIC_DECLARATION_1 => 's',
            TEXT_TOKEN::TEXT_STATIC_DECLARATION_2 => 't',
            TEXT_TOKEN::TEXT_STATIC_DECLARATION_3 => 'a',
            TEXT_TOKEN::TEXT_STATIC_DECLARATION_4 => 't',
            TEXT_TOKEN::TEXT_STATIC_DECLARATION_5 => 'i',
            TEXT_TOKEN::TEXT_STATIC_DECLARATION_6 => 'c',
            TEXT_TOKEN::TEXT_UNSAFE_DECLARATION_1 => 'u',
            TEXT_TOKEN::TEXT_UNSAFE_DECLARATION_2 => 'n',
            TEXT_TOKEN::TEXT_UNSAFE_DECLARATION_3 => 's',
            TEXT_TOKEN::TEXT_UNSAFE_DECLARATION_4 => 'a',
            TEXT_TOKEN::TEXT_UNSAFE_DECLARATION_5 => 'f',
            TEXT_TOKEN::TEXT_UNSAFE_DECLARATION_6 => 'e',
            TEXT_TOKEN::TEXT_IMPORT_DECLARATION_1 => 'i',
            TEXT_TOKEN::TEXT_IMPORT_DECLARATION_2 => 'm',
            TEXT_TOKEN::TEXT_IMPORT_DECLARATION_3 => 'p',
            TEXT_TOKEN::TEXT_IMPORT_DECLARATION_4 => 'o',
            TEXT_TOKEN::TEXT_IMPORT_DECLARATION_5 => 'r',
            TEXT_TOKEN::TEXT_IMPORT_DECLARATION_6 => 't',
            TEXT_TOKEN::TEXT_NEW_DECLARATION_1 => 'n',
            TEXT_TOKEN::TEXT_NEW_DECLARATION_2 => 'e',
            TEXT_TOKEN::TEXT_NEW_DECLARATION_3 => 'w',
            TEXT_TOKEN::TEXT_OTHER(v) => v,
            TEXT_TOKEN::TEXT_DEC(v) => v,
        }
    }
}
impl Into<char> for &TEXT_TOKEN {
    fn into(self) -> char {
        match &self {
            TEXT_TOKEN::TEXT_FUNCTION_DECLARATION_1 => 'f',
            TEXT_TOKEN::TEXT_FUNCTION_DECLARATION_2 => 'n',
            TEXT_TOKEN::TEXT_CLASS_DECLARATION_1 => 'c',
            TEXT_TOKEN::TEXT_CLASS_DECLARATION_2 => 'l',
            TEXT_TOKEN::TEXT_ENUM_DECLARATION_1 => 'e',
            TEXT_TOKEN::TEXT_ENUM_DECLARATION_2 => 'n',
            TEXT_TOKEN::TEXT_ENUM_DECLARATION_3 => 'u',
            TEXT_TOKEN::TEXT_ENUM_DECLARATION_4 => 'm',
            TEXT_TOKEN::TEXT_VAR_DECLARATION_1 => 'v',
            TEXT_TOKEN::TEXT_VAR_DECLARATION_2 => 'a',
            TEXT_TOKEN::TEXT_VAR_DECLARATION_3 => 'r',
            TEXT_TOKEN::TEXT_MUT_DECLARATION_1 => 'm',
            TEXT_TOKEN::TEXT_MUT_DECLARATION_2 => 'u',
            TEXT_TOKEN::TEXT_MUT_DECLARATION_3 => 't',
            TEXT_TOKEN::TEXT_PUB_DECLARATION_2 => 'p',
            TEXT_TOKEN::TEXT_PUB_DECLARATION_1 => 'u',
            TEXT_TOKEN::TEXT_PUB_DECLARATION_3 => 'b',
            TEXT_TOKEN::TEXT_CONST_DECLARATION_1 => 'c',
            TEXT_TOKEN::TEXT_CONST_DECLARATION_2 => 'o',
            TEXT_TOKEN::TEXT_CONST_DECLARATION_3 => 'n',
            TEXT_TOKEN::TEXT_CONST_DECLARATION_4 => 's',
            TEXT_TOKEN::TEXT_CONST_DECLARATION_5 => 't',
            TEXT_TOKEN::TEXT_TYPE_DECLARATION_1 => 't',
            TEXT_TOKEN::TEXT_TYPE_DECLARATION_2 => 'y',
            TEXT_TOKEN::TEXT_TYPE_DECLARATION_3 => 'p',
            TEXT_TOKEN::TEXT_TYPE_DECLARATION_4 => 'e',
            TEXT_TOKEN::TEXT_SWITCH_DECLARATION_1 => 's',
            TEXT_TOKEN::TEXT_SWITCH_DECLARATION_2 => 'w',
            TEXT_TOKEN::TEXT_SWITCH_DECLARATION_3 => 'i',
            TEXT_TOKEN::TEXT_SWITCH_DECLARATION_4 => 't',
            TEXT_TOKEN::TEXT_SWITCH_DECLARATION_5 => 'c',
            TEXT_TOKEN::TEXT_SWITCH_DECLARATION_6 => 'h',
            TEXT_TOKEN::TEXT_RETURN_DECLARATION_1 => 'r',
            TEXT_TOKEN::TEXT_RETURN_DECLARATION_2 => 'e',
            TEXT_TOKEN::TEXT_RETURN_DECLARATION_3 => 't',
            TEXT_TOKEN::TEXT_RETURN_DECLARATION_4 => 'u',
            TEXT_TOKEN::TEXT_RETURN_DECLARATION_5 => 'r',
            TEXT_TOKEN::TEXT_RETURN_DECLARATION_6 => 'n',
            TEXT_TOKEN::TEXT_DERIVE_DECLARATION_1 => 'd',
            TEXT_TOKEN::TEXT_DERIVE_DECLARATION_2 => 'e',
            TEXT_TOKEN::TEXT_DERIVE_DECLARATION_3 => 'r',
            TEXT_TOKEN::TEXT_DERIVE_DECLARATION_4 => 'i',
            TEXT_TOKEN::TEXT_DERIVE_DECLARATION_5 => 'v',
            TEXT_TOKEN::TEXT_DERIVE_DECLARATION_6 => 'e',
            TEXT_TOKEN::TEXT_STATIC_DECLARATION_1 => 's',
            TEXT_TOKEN::TEXT_STATIC_DECLARATION_2 => 't',
            TEXT_TOKEN::TEXT_STATIC_DECLARATION_3 => 'a',
            TEXT_TOKEN::TEXT_STATIC_DECLARATION_4 => 't',
            TEXT_TOKEN::TEXT_STATIC_DECLARATION_5 => 'i',
            TEXT_TOKEN::TEXT_STATIC_DECLARATION_6 => 'c',
            TEXT_TOKEN::TEXT_UNSAFE_DECLARATION_1 => 'u',
            TEXT_TOKEN::TEXT_UNSAFE_DECLARATION_2 => 'n',
            TEXT_TOKEN::TEXT_UNSAFE_DECLARATION_3 => 's',
            TEXT_TOKEN::TEXT_UNSAFE_DECLARATION_4 => 'a',
            TEXT_TOKEN::TEXT_UNSAFE_DECLARATION_5 => 'f',
            TEXT_TOKEN::TEXT_UNSAFE_DECLARATION_6 => 'e',
            TEXT_TOKEN::TEXT_IMPORT_DECLARATION_1 => 'i',
            TEXT_TOKEN::TEXT_IMPORT_DECLARATION_2 => 'm',
            TEXT_TOKEN::TEXT_IMPORT_DECLARATION_3 => 'p',
            TEXT_TOKEN::TEXT_IMPORT_DECLARATION_4 => 'o',
            TEXT_TOKEN::TEXT_IMPORT_DECLARATION_5 => 'r',
            TEXT_TOKEN::TEXT_IMPORT_DECLARATION_6 => 't',
            TEXT_TOKEN::TEXT_NEW_DECLARATION_1 => 'n',
            TEXT_TOKEN::TEXT_NEW_DECLARATION_2 => 'e',
            TEXT_TOKEN::TEXT_NEW_DECLARATION_3 => 'w',
            TEXT_TOKEN::TEXT_OTHER(v) => *v,
            TEXT_TOKEN::TEXT_DEC(v) => *v,
        }
    }
}
impl std::fmt::Display for TEXT_TOKEN {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{}", self.tostr())
    }
}






#[derive(Debug, Eq, PartialEq, Clone, Copy)]
pub enum SIGN_TOKEN {
    SIGN_BRACKET_CURLY_OPEN,
    SIGN_BRACKET_CURLY_CLOSE,
    SIGN_BRACKET_ROUND_OPEN,
    SIGN_BRACKET_ROUND_CLOSE,
    SIGN_BRACKET_SQUARE_OPEN,
    SIGN_BRACKET_SQUARE_CLOSE,
    SIGN_LESS_THAN,
    SIGN_GREATER_THAN,
    SIGN_POINT,
    SIGN_COLON,
    SIGN_COMMA,
    SIGN_SEMICOLON,
    SIGN_DOLLAR,
    SIGN_REFERENCE,
    SIGN_DEREFERENCE,
    SIGN_QUOTATION,
    SIGN_SQUOTATION,
    SIGN_AT,
}
impl SIGN_TOKEN {
    pub fn tostr(&self) -> char { self.into() }
}
impl Into<char> for SIGN_TOKEN {
    fn into(self) -> char {
        match self {
            SIGN_TOKEN::SIGN_BRACKET_CURLY_OPEN => '{',
            SIGN_TOKEN::SIGN_BRACKET_CURLY_CLOSE => '}',
            SIGN_TOKEN::SIGN_BRACKET_ROUND_OPEN => '(',
            SIGN_TOKEN::SIGN_BRACKET_ROUND_CLOSE => ')',
            SIGN_TOKEN::SIGN_BRACKET_SQUARE_OPEN => '[',
            SIGN_TOKEN::SIGN_BRACKET_SQUARE_CLOSE => ']',
            SIGN_TOKEN::SIGN_LESS_THAN => '<',
            SIGN_TOKEN::SIGN_GREATER_THAN => '>',
            SIGN_TOKEN::SIGN_POINT => '.',
            SIGN_TOKEN::SIGN_COLON => ':',
            SIGN_TOKEN::SIGN_COMMA => ',',
            SIGN_TOKEN::SIGN_SEMICOLON => ';',
            SIGN_TOKEN::SIGN_DOLLAR => '$',
            SIGN_TOKEN::SIGN_REFERENCE => '&',
            SIGN_TOKEN::SIGN_DEREFERENCE => '*',
            SIGN_TOKEN::SIGN_QUOTATION => '"',
            SIGN_TOKEN::SIGN_SQUOTATION => '\'',
            SIGN_TOKEN::SIGN_AT => '@',
        }
    }
}
impl Into<char> for &SIGN_TOKEN {
    fn into(self) -> char {
        match self {
            SIGN_TOKEN::SIGN_BRACKET_CURLY_OPEN => '{',
            SIGN_TOKEN::SIGN_BRACKET_CURLY_CLOSE => '}',
            SIGN_TOKEN::SIGN_BRACKET_ROUND_OPEN => '(',
            SIGN_TOKEN::SIGN_BRACKET_ROUND_CLOSE => ')',
            SIGN_TOKEN::SIGN_BRACKET_SQUARE_OPEN => '[',
            SIGN_TOKEN::SIGN_BRACKET_SQUARE_CLOSE => ']',
            SIGN_TOKEN::SIGN_LESS_THAN => '<',
            SIGN_TOKEN::SIGN_GREATER_THAN => '>',
            SIGN_TOKEN::SIGN_POINT => '.',
            SIGN_TOKEN::SIGN_COLON => ':',
            SIGN_TOKEN::SIGN_COMMA => ',',
            SIGN_TOKEN::SIGN_SEMICOLON => ';',
            SIGN_TOKEN::SIGN_DOLLAR => '$',
            SIGN_TOKEN::SIGN_REFERENCE => '&',
            SIGN_TOKEN::SIGN_DEREFERENCE => '*',
            SIGN_TOKEN::SIGN_QUOTATION => '"',
            SIGN_TOKEN::SIGN_SQUOTATION => '\'',
            SIGN_TOKEN::SIGN_AT => '@',
        }
    }
}
impl std::fmt::Display for SIGN_TOKEN {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{}", self.tostr())
    }
}